import os
import zipfile
import io
from datetime import datetime

class BaseCodeGenerator:
    def __init__(self, project):
        self.project = project
        self.models = project.database_models.prefetch_related('fields', 'outgoing_relationships').all()
    
    def generate_models_code(self):
        """Generate models code for the framework"""
        raise NotImplementedError
    
    def generate_serializers_code(self):
        """Generate serializers code"""
        raise NotImplementedError
    
    def generate_views_code(self):
        """Generate views code"""
        raise NotImplementedError
    
    def generate_urls_code(self):
        """Generate URLs code"""
        raise NotImplementedError
    
    def generate_settings_code(self):
        """Generate settings code"""
        raise NotImplementedError
    
    def generate_requirements(self):
        """Generate requirements file"""
        raise NotImplementedError
    
    def generate_project(self):
        """Generate complete project structure"""
        return {
            'models.py': self.generate_models_code(),
            'serializers.py': self.generate_serializers_code(),
            'views.py': self.generate_views_code(),
            'urls.py': self.generate_urls_code(),
            'settings.py': self.generate_settings_code(),
            'requirements.txt': self.generate_requirements(),
        }
    
    def generate_preview(self):
        """Generate preview of code without full project structure"""
        return {
            'models': self.generate_models_code(),
            'serializers': self.generate_serializers_code(),
            'views': self.generate_views_code(),
        }
    
    def create_zip_file(self, project_structure):
        """Create ZIP file from project structure"""
        zip_buffer = io.BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for file_path, content in project_structure.items():
                zip_file.writestr(file_path, content)
            
            # Add basic project files
            zip_file.writestr('README.md', self.generate_readme())
            zip_file.writestr('.env.example', self.generate_env_example())
            
            # Add boilerplate files based on project options
            if self.project.include_docker:
                zip_file.writestr('Dockerfile', self.generate_dockerfile())
            
        zip_buffer.seek(0)
        return zip_buffer
    
    def generate_readme(self):
        """Generate README file"""
        return f"""# {self.project.name}

Generated by Rapid Scaffolder on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Setup Instructions

1. Install dependencies:
{'pip install -r requirements.txt' if self.project.framework == 'django' else 'npm install'}

2. Set up environment variables:
cp .env.example .env

3. Run migrations:
{'python manage.py migrate' if self.project.framework == 'django' else 'npx sequelize-cli db:migrate'}

4. Start development server:
{'python manage.py runserver' if self.project.framework == 'django' else 'npm run dev'}

## Project Structure

This project was automatically generated and includes:
- Database models
- REST API endpoints
- Serializers/Validators
- Basic authentication setup
"""

    def generate_env_example(self):
        """Generate environment example file"""
        if self.project.framework == 'django':
            return """DEBUG=True
SECRET_KEY=your-secret-key-here
DATABASE_URL=sqlite:///db.sqlite3
ALLOWED_HOSTS=localhost,127.0.0.1
"""
        else:
            return """NODE_ENV=development
PORT=3000
DATABASE_URL=sqlite://db.sqlite3
JWT_SECRET=your-jwt-secret-here
"""

    def generate_dockerfile(self):
        """Generate Dockerfile"""
        if self.project.framework == 'django':
            return """FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
"""
        else:
            return """FROM node:18-alpine

WORKDIR /app

COPY package*.json .
RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "run", "dev"]
"""


class DjangoCodeGenerator(BaseCodeGenerator):
    def generate_models_code(self):
        """Generate Django models.py content with proper relationships"""
        models_code = """from django.db import models
from django.contrib.auth.models import User

"""
        
        for model in self.models:
            models_code += f"class {model.name}(models.Model):\n"
            
            # First, add all regular fields (non-relationship fields)
            for field in model.fields.all():
                # Skip fields that are part of relationships (they'll be replaced with relationship fields)
                if not getattr(field, 'relationship_data', None):
                    field_def = self._generate_django_field(field)
                    if field_def:
                        models_code += f"    {field_def}\n"
            
            # Then, add relationship fields
            for field in model.fields.all():
                relationship_data = getattr(field, 'relationship_data', None)
                if relationship_data:
                    rel_def = self._generate_django_relationship_from_data(field, relationship_data)
                    if rel_def:
                        models_code += f"    {rel_def}\n"
            
            # Add Meta class and __str__
            display_field = getattr(model, 'display_field', 'id') or 'id'
            models_code += f"""
    class Meta:
        ordering = ['-id']
        verbose_name = '{model.name}'
        verbose_name_plural = '{model.name}s'

    def __str__(self):
        return str(self.{display_field})

"""
        
        return models_code
    
    def _generate_django_field(self, field):
        """Generate Django field definition for regular fields only"""
        field_type_map = {
            'char': 'models.CharField',
            'text': 'models.TextField',
            'integer': 'models.IntegerField',
            'boolean': 'models.BooleanField',
            'date': 'models.DateField',
            'datetime': 'models.DateTimeField',
            'email': 'models.EmailField',
            'url': 'models.URLField',
            'image': 'models.ImageField',
            'file': 'models.FileField',
            'decimal': 'models.DecimalField',
            'float': 'models.FloatField',
            'json': 'models.JSONField',
        }
        
        # Skip fields that have relationship data (they'll be handled separately)
        if getattr(field, 'relationship_data', None):
            return None
            
        field_args = []
        field_type = field_type_map.get(field.field_type, 'models.CharField')
        
        # Add max_length for char fields
        if field.field_type == 'char' and field.max_length:
            field_args.append(f"max_length={field.max_length}")
        elif field.field_type == 'char':
            field_args.append("max_length=255")
        
        # Add other field options
        if field.null:
            field_args.append("null=True")
        if field.blank:
            field_args.append("blank=True")
        if field.unique:
            field_args.append("unique=True")
        if field.primary_key:
            field_args.append("primary_key=True")
        if field.default_value:
            # Handle different types of default values
            if field.field_type in ['integer', 'boolean']:
                field_args.append(f"default={field.default_value}")
            else:
                field_args.append(f"default='{field.default_value}'")
        if field.help_text:
            field_args.append(f"help_text='{field.help_text}'")
        
        args_str = ", ".join(field_args)
        return f"{field.name} = {field_type}({args_str})"
    
    def _generate_django_relationship_from_data(self, field, relationship_data):
        """Generate Django relationship from field relationship data"""
        if not relationship_data or 'references' not in relationship_data:
            return None
            
        # Map frontend relationship types to Django relationship types
        frontend_type = relationship_data.get('relationshipType', '1:M')
        django_relationship_type = self._map_relationship_type(frontend_type)
        
        # Get the referenced model and field
        referenced_model = relationship_data['references']['model']
        referenced_field = relationship_data['references']['field']
        
        # Create a new field name for the relationship
        # Use a more descriptive name than the original field name
        relationship_field_name = self._generate_relationship_field_name(
            field.name, referenced_model, django_relationship_type
        )
        
        # Generate the relationship field
        if django_relationship_type == 'one_to_one':
            return self._generate_one_to_one_field(relationship_field_name, referenced_model, relationship_data)
        elif django_relationship_type == 'foreign_key':
            return self._generate_foreign_key_field(relationship_field_name, referenced_model, relationship_data)
        elif django_relationship_type == 'many_to_many':
            return self._generate_many_to_many_field(relationship_field_name, referenced_model, relationship_data)
        else:
            return self._generate_foreign_key_field(relationship_field_name, referenced_model, relationship_data)
    
    def _generate_relationship_field_name(self, original_field_name, referenced_model, relationship_type):
        """Generate a meaningful name for the relationship field"""
        model_name_lower = referenced_model.lower()
        
        if relationship_type == 'one_to_one':
            return f"{model_name_lower}"
        elif relationship_type == 'foreign_key':
            return f"{model_name_lower}"
        elif relationship_type == 'many_to_many':
            return f"{model_name_lower}s"
        else:
            return f"{model_name_lower}"
    
    def _generate_one_to_one_field(self, field_name, referenced_model, relationship_data):
        """Generate a OneToOneField"""
        args = [referenced_model]
        on_delete = relationship_data.get('onDelete', 'CASCADE')
        args.append(f"on_delete=models.{on_delete}")
        
        # Add related_name
        related_name = f"{field_name}_set"
        args.append(f"related_name='{related_name}'")
        
        # Add field options
        if relationship_data.get('null'):
            args.append("null=True")
        if relationship_data.get('blank'):
            args.append("blank=True")
        
        return f"{field_name} = models.OneToOneField({', '.join(args)})"
    
    def _generate_foreign_key_field(self, field_name, referenced_model, relationship_data):
        """Generate a ForeignKey field"""
        args = [referenced_model]
        on_delete = relationship_data.get('onDelete', 'CASCADE')
        args.append(f"on_delete=models.{on_delete}")
        
        # Add related_name
        related_name = f"{field_name}_set"
        args.append(f"related_name='{related_name}'")
        
        # Add field options
        if relationship_data.get('null'):
            args.append("null=True")
        if relationship_data.get('blank'):
            args.append("blank=True")
        
        return f"{field_name} = models.ForeignKey({', '.join(args)})"
    
    def _generate_many_to_many_field(self, field_name, referenced_model, relationship_data):
        """Generate a ManyToManyField"""
        args = [referenced_model]
        
        # Add related_name
        related_name = f"{field_name}_set"
        args.append(f"related_name='{related_name}'")
        
        # Add through table if specified
        if relationship_data.get('through'):
            args.append(f"through='{relationship_data['through']}'")
        
        # Add field options
        if relationship_data.get('null'):
            args.append("null=True")
        if relationship_data.get('blank'):
            args.append("blank=True")
        
        return f"{field_name} = models.ManyToManyField({', '.join(args)})"
    
    def _map_relationship_type(self, frontend_type):
        """Map frontend relationship types to Django relationship types"""
        if frontend_type == '1:1':
            return 'one_to_one'
        elif frontend_type == '1:M':
            return 'foreign_key'
        elif frontend_type == 'M:M':
            return 'many_to_many'
        else:
            return 'foreign_key'
    
    # ... keep the rest of your methods (serializers, views, urls, etc.) the same
    def generate_serializers_code(self):
        """Generate DRF serializers"""
        serializers_code = """from rest_framework import serializers
from .models import *

"""
        
        for model in self.models:
            serializers_code += f"class {model.name}Serializer(serializers.ModelSerializer):\n"
            serializers_code += f"    class Meta:\n"
            serializers_code += f"        model = {model.name}\n"
            serializers_code += f"        fields = '__all__'\n\n"
        
        return serializers_code
    
    def generate_views_code(self):
        """Generate DRF views"""
        views_code = """from rest_framework import viewsets, permissions
from .models import *
from .serializers import *

"""
        
        for model in self.models:
            views_code += f"class {model.name}ViewSet(viewsets.ModelViewSet):\n"
            views_code += f"    queryset = {model.name}.objects.all()\n"
            views_code += f"    serializer_class = {model.name}Serializer\n"
            views_code += f"    permission_classes = [permissions.IsAuthenticatedOrReadOnly]\n\n"
        
        return views_code
    
    def generate_urls_code(self):
        """Generate Django URLs"""
        urls_code = """from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

router = DefaultRouter()

"""
        
        for model in self.models:
            model_lower = model.name.lower()
            urls_code += f"router.register(r'{model_lower}', views.{model.name}ViewSet)\n"
        
        urls_code += """
urlpatterns = [
    path('', include(router.urls)),
]
"""
        return urls_code
    
    def generate_settings_code(self):
        """Generate Django settings snippet"""
        return """# This is a settings snippet for your generated project
# Add these to your existing Django settings

INSTALLED_APPS += [
    'rest_framework',
    'corsheaders',
]

REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticatedOrReadOnly',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20
}

# CORS settings (if needed)
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
]
"""
    
    def generate_requirements(self):
        """Generate requirements.txt"""
        requirements = """Django>=5.0,<6.0
djangorestframework>=3.14,<4.0
django-cors-headers>=4.0,<5.0
Pillow>=10.0,<11.0
"""
        
        if self.project.include_docker:
            requirements += "gunicorn>=20.0,<21.0\n"
        
        return requirements


class ExpressCodeGenerator(BaseCodeGenerator):
    def generate_models_code(self):
        """Generate Express/Sequelize models"""
        # Simplified implementation for now
        return "// Express.js models would be generated here\n"
    
    def generate_serializers_code(self):
        """Generate Express validators"""
        return "// Express.js validators would be generated here\n"
    
    def generate_views_code(self):
        """Generate Express controllers"""
        return "// Express.js controllers would be generated here\n"
    
    def generate_urls_code(self):
        """Generate Express routes"""
        return "// Express.js routes would be generated here\n"
    
    def generate_settings_code(self):
        """Generate Express app configuration"""
        return "// Express.js app configuration would be generated here\n"
    
    def generate_requirements(self):
        """Generate package.json"""
        return """{
  "name": "%s",
  "version": "1.0.0",
  "description": "Generated by Rapid Scaffolder",
  "main": "app.js",
  "scripts": {
    "dev": "node app.js",
    "start": "node app.js"
  },
  "dependencies": {
    "express": "^4.18.0",
    "sequelize": "^6.0.0",
    "sqlite3": "^5.0.0",
    "cors": "^2.8.0"
  }
}""" % self.project.name